"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""


from io import BytesIO
import struct

class state_feedback(object):

    __slots__ = ["sec", "nanosec", "utime", "seq", "act_status_type", "error_msg", "stateID", "substateID", "state_msg"]

    __typenames__ = ["int32_t", "int32_t", "int64_t", "int32_t", "int8_t", "string", "int8_t", "int8_t", "string"]

    __dimensions__ = [None, None, None, None, None, None, None, None, None]

    kIdle = 0
    """
    Sequence number
    -------- ACT status type ----------------------------
    """
    kSuccess = 1
    kExecuting = 2
    kPaused = 3
    kCollision = 4
    kFail = -1
    kGoStand = 1
    """
    Error message
    -------- stateID status type ----------------------------
    """
    kGoHome = 2
    kMove1 = 3
    kMove2 = 4
    kError = -1
    kEnter = 0
    """ -------- substateID status type ---------------------------- """
    kDuring = 1
    kExit = 2

    def __init__(self):
        self.sec = 0
        """ LCM Type: int32_t """
        self.nanosec = 0
        """
        Timestamp seconds
        LCM Type: int32_t
        """

        self.utime = 0
        """
        Timestamp nanoseconds
        LCM Type: int64_t
        """

        self.seq = 0
        """
        Microsecond timestamp
        LCM Type: int32_t
        """

        self.act_status_type = 0
        """ LCM Type: int8_t """
        self.error_msg = ""
        """
        ACT status type
        LCM Type: string
        """

        self.stateID = 0
        """ LCM Type: int8_t """
        self.substateID = 0
        """ LCM Type: int8_t """
        self.state_msg = ""
        """
        -------- state_msg string ----------------------------
        LCM Type: string
        """


    def encode(self):
        buf = BytesIO()
        buf.write(state_feedback._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">iiqib", self.sec, self.nanosec, self.utime, self.seq, self.act_status_type))
        __error_msg_encoded = self.error_msg.encode('utf-8')
        buf.write(struct.pack('>I', len(__error_msg_encoded)+1))
        buf.write(__error_msg_encoded)
        buf.write(b"\0")
        buf.write(struct.pack(">bb", self.stateID, self.substateID))
        __state_msg_encoded = self.state_msg.encode('utf-8')
        buf.write(struct.pack('>I', len(__state_msg_encoded)+1))
        buf.write(__state_msg_encoded)
        buf.write(b"\0")

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != state_feedback._get_packed_fingerprint():
            raise ValueError("Decode error")
        return state_feedback._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = state_feedback()
        self.sec, self.nanosec, self.utime, self.seq, self.act_status_type = struct.unpack(">iiqib", buf.read(21))
        __error_msg_len = struct.unpack('>I', buf.read(4))[0]
        self.error_msg = buf.read(__error_msg_len)[:-1].decode('utf-8', 'replace')
        self.stateID, self.substateID = struct.unpack(">bb", buf.read(2))
        __state_msg_len = struct.unpack('>I', buf.read(4))[0]
        self.state_msg = buf.read(__state_msg_len)[:-1].decode('utf-8', 'replace')
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if state_feedback in parents: return 0
        tmphash = (0x7229a11bea27299d) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if state_feedback._packed_fingerprint is None:
            state_feedback._packed_fingerprint = struct.pack(">Q", state_feedback._get_hash_recursive([]))
        return state_feedback._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", state_feedback._get_packed_fingerprint())[0]

